/// Six-Hump Camel Function - Observer Logging
///
/// This file is used to generate the data for the plots in the documentation.
/// It generates CSV files logging the progress of both Stage 1 (scatter search)
/// and Stage 2 (local optimization).
///
/// It also generates a CSV file containing the initial population generated by the scatter search.
///
/// The Six-Hump Camel function is defined as follows:
///
/// f(x) = (4 - 2.1 x₁² + x₁⁴ / 3) x₁² + x₁ x₂ + (-4 + 4 x₂²) x₂²
///
/// The function is defined on the domain x₁ ∈ [-3, 3] and x₂ ∈ [-2, 2].
/// The function has two global minima at f(0.0898, -0.7126) = -1.0316 and f(-0.0898, 0.7126) = -1.0316.
/// The function is continuous, differentiable and non-convex.
///
/// References:
///
/// Molga, M., & Smutnicki, C. Test functions for optimization needs (April 3, 2005), pp. 27-28. Retrieved January 2025, from https://robertmarks.org/Classes/ENGR5358/Papers/functions.pdf
use globalsearch::local_solver::builders::COBYLABuilder;
use globalsearch::observers::Observer;
use globalsearch::oqnlp::OQNLP;
use globalsearch::problem::Problem;
use globalsearch::scatter_search::ScatterSearch;
use globalsearch::types::{EvaluationError, LocalSolverType, OQNLPParams};
use ndarray::{array, Array1, Array2};
use std::fs::File;
use std::io::{BufWriter, Write};
use std::sync::{Arc, Mutex};
use std::thread::sleep;

#[derive(Debug, Clone)]
pub struct SixHumpCamel;

impl Problem for SixHumpCamel {
    fn objective(&self, x: &Array1<f64>) -> Result<f64, EvaluationError> {
        Ok((4.0 - 2.1 * x[0].powi(2) + x[0].powi(4) / 3.0) * x[0].powi(2)
            + x[0] * x[1]
            + (-4.0 + 4.0 * x[1].powi(2)) * x[1].powi(2))
    }

    fn variable_bounds(&self) -> Array2<f64> {
        array![[-3.0, 3.0], [-2.0, 2.0]]
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create CSV files for Stage 1, Stage 2, and initial population logging
    let stage1_log = Arc::new(Mutex::new(BufWriter::new(File::create("stage1_log.csv")?)));
    let stage2_log = Arc::new(Mutex::new(BufWriter::new(File::create("stage2_log.csv")?)));
    let population_log = Arc::new(Mutex::new(BufWriter::new(File::create("population_log.csv")?)));

    // Write CSV headers
    {
        let mut file = stage1_log.lock().unwrap();
        writeln!(
            file,
            "substage,ref_set_size,best_objective,best_x1,best_x2,fn_evals,trial_points,total_time_sec"
        )?;
    }

    {
        let mut file = stage2_log.lock().unwrap();
        writeln!(file, "iteration,best_objective,best_x1,best_x2,solution_count,threshold,local_calls,improved_calls,fn_evals,unchanged_cycles,total_time_sec")?;
    }

    {
        let mut file = population_log.lock().unwrap();
        writeln!(file, "x1,x2,objective")?;
    }

    let problem = SixHumpCamel;

    let params = OQNLPParams {
        iterations: 50,
        wait_cycle: 10,
        threshold_factor: 0.5,
        distance_factor: 0.75,
        population_size: 50,
        local_solver_type: LocalSolverType::COBYLA,
        local_solver_config: COBYLABuilder::default().build(),
        seed: 50002099,
    };

    // First, run scatter search to get the initial population
    println!("Generating initial population...");
    let scatter_search = ScatterSearch::new(problem.clone(), params.clone())?;
    let (initial_population_with_objectives, _) = scatter_search.run()?;

    // Log the initial population
    {
        let mut file = population_log.lock().unwrap();
        for (point, objective) in &initial_population_with_objectives {
            writeln!(file, "{:.8},{:.8},{:.8}", point[0], point[1], objective)?;
        }
    }
    println!(
        "Initial population saved to population_log.csv ({} points)",
        initial_population_with_objectives.len()
    );

    // Clone Arcs for use in closures
    let stage1_clone = Arc::clone(&stage1_log);
    let stage2_clone = Arc::clone(&stage2_log);

    // Create an observer with comprehensive tracking for both stages
    let observer = Observer::new()
        .with_stage1_tracking()
        .with_stage2_tracking()
        .with_timing()
        .unique_updates()
        .with_callback(move |obs| {
            // Log Stage 1 (Scatter Search) data
            if let Some(stage1) = obs.stage1() {
                if let Ok(mut file) = stage1_clone.lock() {
                    if let Some(point) = stage1.best_point() {
                        let _ = writeln!(
                            file,
                            "{},{},{:.8},{:.8},{:.8},{},{},{:.6}",
                            stage1.current_substage(),
                            stage1.reference_set_size(),
                            stage1.best_objective(),
                            point[0],
                            point[1],
                            stage1.function_evaluations(),
                            stage1.trial_points_generated(),
                            stage1.total_time().unwrap_or(0.0)
                        );
                    } else {
                        let _ = writeln!(
                            file,
                            "{},{},{:.8},,,{},{},{:.6}",
                            stage1.current_substage(),
                            stage1.reference_set_size(),
                            stage1.best_objective(),
                            stage1.function_evaluations(),
                            stage1.trial_points_generated(),
                            stage1.total_time().unwrap_or(0.0)
                        );
                    }
                }
            }

            // Log Stage 2 (Optimization) data
            if let Some(stage2) = obs.stage2() {
                if let Ok(mut file) = stage2_clone.lock() {
                    if let Some(point) = stage2.best_point() {
                        let _ = writeln!(
                            file,
                            "{},{:.8},{:.8},{:.8},{},{:.8},{},{},{},{},{:.6}",
                            stage2.current_iteration(),
                            stage2.best_objective(),
                            point[0],
                            point[1],
                            stage2.solution_set_size(),
                            stage2.threshold_value(),
                            stage2.local_solver_calls(),
                            stage2.improved_local_calls(),
                            stage2.function_evaluations(),
                            stage2.unchanged_cycles(),
                            stage2.total_time().unwrap_or(0.0)
                        );
                    } else {
                        let _ = writeln!(
                            file,
                            "{},{:.8},,{},{:.8},{},{},{},{},{:.6}",
                            stage2.current_iteration(),
                            stage2.best_objective(),
                            stage2.solution_set_size(),
                            stage2.threshold_value(),
                            stage2.local_solver_calls(),
                            stage2.improved_local_calls(),
                            stage2.function_evaluations(),
                            stage2.unchanged_cycles(),
                            stage2.total_time().unwrap_or(0.0)
                        );
                    }
                }
            }
        })
        .with_callback_frequency(1);

    let mut oqnlp = OQNLP::new(problem, params)?.add_observer(observer);

    // Warm-up sleep
    sleep(std::time::Duration::from_millis(1000));

    println!("Running optimization...\n");
    let solution_set = oqnlp.run()?;

    // Flush all buffered writers to ensure data is written
    {
        let mut file = stage1_log.lock().unwrap();
        file.flush()?;
    }
    {
        let mut file = stage2_log.lock().unwrap();
        file.flush()?;
    }
    {
        let mut file = population_log.lock().unwrap();
        file.flush()?;
    }

    println!("\nOptimization Complete");
    println!("{}", solution_set);

    println!("\nOptimization logs saved:");
    println!("  - population_log.csv (initial population from scatter search)");
    println!("  - stage1_log.csv (scatter search metrics)");
    println!("  - stage2_log.csv (local optimization metrics)");

    Ok(())
}
